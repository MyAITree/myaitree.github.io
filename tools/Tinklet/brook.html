<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReadFlow Pro - Click & Drag Highlighting</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            margin-top: 20px;
        }
        
        header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 25px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 8s infinite linear;
        }
        
        @keyframes pulse {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
            position: relative;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            position: relative;
        }
        
        .content {
            padding: 30px;
        }
        
        .text-container {
            height: 350px;
            overflow-y: auto;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
            margin-bottom: 25px;
            position: relative;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
            user-select: none;
        }
        
        .text-content {
            font-size: 1.25rem;
            line-height: 1.8;
            color: #2c3e50;
        }
        
        .highlight {
            background: linear-gradient(120deg, #f6d365 0%, #fda085 100%);
            border-radius: 4px;
            padding: 2px 4px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .manual-highlight {
            background: linear-gradient(120deg, #a8e6cf 0%, #dcedc1 100%);
            border-radius: 4px;
            padding: 2px 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .read-text {
            color: #95a5a6 !important;
            transition: color 0.5s ease;
        }
        
        .focused-read-text {
            color: transparent !important;
            background-color: #f8f9fa !important;
            transition: all 0.5s ease;
        }
        
        .controls {
            background: #eef2f7;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.1rem;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #3498db, #2c3e50);
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border: 2px solid #3498db;
            transition: all 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .value-display {
            min-width: 50px;
            text-align: center;
            font-weight: 700;
            color: #3498db;
            font-size: 1.1rem;
            background: white;
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .instructions {
            background: linear-gradient(135deg, #d4e6ff 0%, #e8f4fd 100%);
            padding: 25px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 5px solid #2196F3;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .instructions h3 {
            color: #0d47a1;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 12px;
            font-size: 1.05rem;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            background: #2c3e50;
            color: white;
            padding: 15px 25px;
            font-size: 1rem;
        }
        
        .cursor-hidden {
            cursor: none;
        }
        
        button {
            background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .demo-text {
            margin-top: 25px;
            font-style: italic;
            color: rgba(255,255,255,0.8);
            text-align: center;
            font-size: 1.1rem;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .virtual-cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            background: rgba(231, 76, 60, 0.9);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            transition: transform 0.05s;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
            display: none;
            border: 2px solid white;
        }
        
        .virtual-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: none;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            animation: fadeInOut 2s infinite;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-top: 15px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            text-align: center;
        }
        
        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            flex: 1;
            margin: 0 10px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #3498db;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .mode-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2ecc71;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: none;
        }
        
        .focus-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .focus-btn {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            flex: 1;
        }
        
        .focus-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.3);
        }
        
        .mode-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .mode-btn {
            background: linear-gradient(135deg, #1abc9c, #16a085);
            flex: 1;
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.3);
        }
        
        .selection-info {
            background: rgba(52, 152, 219, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
            display: none;
        }
    </style>
</head>
<body>
    <div class="virtual-cursor" id="virtual-cursor"></div>
    <div class="mode-indicator" id="mode-indicator">Infinite Mode Active</div>
    
    <div class="container">
        <header>
            <h1>ReadFlow Pro</h1>
            <p class="subtitle">Click & Drag Highlighting - Mark Text Precisely</p>
        </header>
        
        <div class="content">
            <div class="controls">
                <div class="control-group">
                    <label>Reading Mode</label>
                    <div class="mode-controls">
                        <button id="flow-mode" class="mode-btn active">Flow Reading</button>
                        <button id="select-mode" class="mode-btn">Click & Select</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="sensitivity">Reading Sensitivity</label>
                    <div class="slider-container">
                        <input type="range" id="sensitivity" min="1" max="10" value="5">
                        <span class="value-display" id="sensitivity-value">5</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="highlight-speed">Flow Speed</label>
                    <div class="slider-container">
                        <input type="range" id="highlight-speed" min="1" max="10" value="5">
                        <span class="value-display" id="speed-value">5</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Focus Mode</label>
                    <div class="focus-controls">
                        <button id="focus-off" class="focus-btn active">Normal</button>
                        <button id="focus-fade" class="focus-btn">Fade Read Text</button>
                        <button id="focus-hide" class="focus-btn">Hide Read Text</button>
                    </div>
                </div>
                
                <div class="selection-info" id="selection-info">
                    <strong>Selection Mode:</strong> Click to start highlighting, drag to extend selection
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                
                <div class="button-group">
                    <button id="start-btn">Start ReadFlow</button>
                    <button id="reset-btn">Reset</button>
                    <button id="toggle-cursor-btn">Show System Cursor</button>
                    <button id="clear-highlights">Clear Manual Highlights</button>
                </div>
            </div>
            
            <div class="text-container">
                <div class="scroll-indicator" id="scroll-indicator">Infinite Scrolling Active</div>
                <div class="text-content" id="text-content">
                    <p>Welcome to ReadFlow Pro with advanced Click & Drag Highlighting. This powerful feature allows you to precisely mark important text sections with manual highlighting while maintaining all the benefits of our flow reading technology.</p>
                    
                    <p>In Selection Mode, simply click once to highlight text at your cursor position. Continue holding and dragging to extend your selection across multiple words, sentences, or paragraphs. This is perfect for marking key information, important quotes, or sections you want to review later.</p>
                    
                    <p>The manual highlights persist separately from the automatic flow highlighting, allowing you to combine both approaches. Use flow reading for general progression through text, and manual selection for specific important passages.</p>
                    
                    <p>Research shows that active reading techniques like highlighting improve information retention by up to 50%. By combining the focus of flow reading with the engagement of manual selection, you create a powerful reading and learning environment.</p>
                    
                    <p>Try switching between Flow Reading mode for continuous progression and Click & Select mode for precise highlighting. You can always clear manual highlights and start fresh, or keep them as visual markers of important content.</p>
                    
                    <p>This dual-mode approach makes ReadFlow Pro ideal for studying, research, document review, or any situation where you need both efficient reading and precise text marking capabilities.</p>
                </div>
            </div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="words-read">0</div>
                    <div class="stat-label">Words Read</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="reading-time">0:00</div>
                    <div class="stat-label">Reading Time</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="manual-highlights">0</div>
                    <div class="stat-label">Manual Highlights</div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>Dual Mode Operation</h3>
                <ul>
                    <li><strong>Flow Reading Mode:</strong> Automatic highlighting controlled by mouse movement</li>
                    <li><strong>Click & Select Mode:</strong> Manual highlighting with click and drag</li>
                    <li><strong>Click once</strong> to highlight text at cursor position</li>
                    <li><strong>Click and drag</strong> to extend selection across text</li>
                    <li><strong>Manual highlights persist</strong> separately from flow highlights</li>
                    <li><strong>Combine both modes</strong> for comprehensive reading and marking</li>
                </ul>
            </div>
        </div>
        
        <div class="status-bar">
            <div>Status: <span id="status">Ready to Start</span></div>
            <div>Progress: <span id="progress">0%</span></div>
            <div>Mode: <span id="mode-status">Flow Reading</span></div>
        </div>
    </div>
    
    <p class="demo-text">Try both modes: Flow Reading for continuous progression, Click & Select for precise highlighting</p>

    <script>
        class ReadFlowPro {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.textContainer = document.querySelector('.text-container');
                this.isActive = false;
                this.currentPosition = 0;
                this.totalChars = 0;
                this.sensitivity = 5;
                this.highlightSpeed = 5;
                this.lastMouseX = 0;
                this.cursorVisible = false;
                this.virtualCursor = document.getElementById('virtual-cursor');
                this.scrollIndicator = document.getElementById('scroll-indicator');
                this.modeIndicator = document.getElementById('mode-indicator');
                this.pointerLocked = false;
                this.wordsRead = 0;
                this.startTime = null;
                this.readingTimer = null;
                this.focusMode = 'normal';
                this.readingMode = 'flow'; // 'flow' or 'select'
                this.isSelecting = false;
                this.selectionStart = 0;
                this.selectionEnd = 0;
                this.manualHighlights = [];
                this.manualHighlightCount = 0;
                
                this.init();
            }
            
            init() {
                this.calculateTextLength();
                this.setupEventListeners();
                this.updateControls();
                this.hideSystemCursor();
                this.setupFocusButtons();
                this.setupModeButtons();
            }
            
            setupModeButtons() {
                const flowMode = document.getElementById('flow-mode');
                const selectMode = document.getElementById('select-mode');
                const selectionInfo = document.getElementById('selection-info');
                
                flowMode.addEventListener('click', () => {
                    this.setReadingMode('flow');
                    flowMode.classList.add('active');
                    selectMode.classList.remove('active');
                    selectionInfo.style.display = 'none';
                    document.getElementById('mode-status').textContent = 'Flow Reading';
                });
                
                selectMode.addEventListener('click', () => {
                    this.setReadingMode('select');
                    selectMode.classList.add('active');
                    flowMode.classList.remove('active');
                    selectionInfo.style.display = 'block';
                    document.getElementById('mode-status').textContent = 'Click & Select';
                });
                
                // Clear highlights button
                document.getElementById('clear-highlights').addEventListener('click', () => {
                    this.clearManualHighlights();
                });
            }
            
            setReadingMode(mode) {
                this.readingMode = mode;
                
                if (mode === 'flow' && this.isActive) {
                    this.textContainer.requestPointerLock();
                } else if (mode === 'select' && this.pointerLocked) {
                    document.exitPointerLock();
                }
            }
            
            setupFocusButtons() {
                const focusOff = document.getElementById('focus-off');
                const focusFade = document.getElementById('focus-fade');
                const focusHide = document.getElementById('focus-hide');
                
                focusOff.addEventListener('click', () => {
                    this.setFocusMode('normal');
                    this.updateFocusButtons(focusOff, focusFade, focusHide);
                });
                
                focusFade.addEventListener('click', () => {
                    this.setFocusMode('fade');
                    this.updateFocusButtons(focusFade, focusOff, focusHide);
                });
                
                focusHide.addEventListener('click', () => {
                    this.setFocusMode('hide');
                    this.updateFocusButtons(focusHide, focusOff, focusFade);
                });
            }
            
            updateFocusButtons(activeBtn, inactiveBtn1, inactiveBtn2) {
                activeBtn.classList.add('active');
                inactiveBtn1.classList.remove('active');
                inactiveBtn2.classList.remove('active');
            }
            
            setFocusMode(mode) {
                this.focusMode = mode;
                document.getElementById('focus-status').textContent = 
                    mode === 'normal' ? 'Normal' : 
                    mode === 'fade' ? 'Fade Read Text' : 'Hide Read Text';
                
                if (this.isActive) {
                    this.updateDisplay();
                }
            }
            
            calculateTextLength() {
                const text = this.container.textContent || this.container.innerText;
                this.totalChars = text.length;
                this.originalText = text;
                
                // Count words for stats
                this.totalWords = text.split(/\s+/).filter(word => word.length > 0).length;
            }
            
            setupEventListeners() {
                // Mouse movement with pointer lock for infinite movement
                document.addEventListener('mousemove', (e) => {
                    if (!this.isActive) return;
                    
                    if (this.readingMode === 'flow' && this.pointerLocked) {
                        this.handleFlowMouseMove(e);
                    } else if (this.readingMode === 'select' && this.isSelecting) {
                        this.handleSelectionMouseMove(e);
                    }
                });
                
                // Mouse down for selection mode
                this.textContainer.addEventListener('mousedown', (e) => {
                    if (this.readingMode === 'select' && this.isActive) {
                        this.startSelection(e);
                    }
                });
                
                // Mouse up for selection mode
                document.addEventListener('mouseup', (e) => {
                    if (this.readingMode === 'select' && this.isSelecting) {
                        this.finishSelection();
                    }
                });
                
                // Pointer lock event handlers
                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = !!document.pointerLockElement;
                    this.updateModeStatus();
                });
                
                // Control elements
                const sensitivitySlider = document.getElementById('sensitivity');
                const speedSlider = document.getElementById('highlight-speed');
                const startBtn = document.getElementById('start-btn');
                const resetBtn = document.getElementById('reset-btn');
                const toggleCursorBtn = document.getElementById('toggle-cursor-btn');
                
                sensitivitySlider.addEventListener('input', () => {
                    this.sensitivity = parseInt(sensitivitySlider.value);
                    document.getElementById('sensitivity-value').textContent = this.sensitivity;
                });
                
                speedSlider.addEventListener('input', () => {
                    this.highlightSpeed = parseInt(speedSlider.value);
                    document.getElementById('speed-value').textContent = this.highlightSpeed;
                });
                
                startBtn.addEventListener('click', () => {
                    this.startReadFlow();
                });
                
                resetBtn.addEventListener('click', () => {
                    this.reset();
                });
                
                toggleCursorBtn.addEventListener('click', () => {
                    this.toggleCursor();
                });
                
                // Click on text container to request pointer lock (flow mode only)
                this.textContainer.addEventListener('click', (e) => {
                    if (this.readingMode === 'flow' && this.isActive && !this.pointerLocked) {
                        this.textContainer.requestPointerLock();
                    }
                });
            }
            
            handleFlowMouseMove(e) {
                // Use movementX for pointer lock (infinite movement)
                const deltaX = e.movementX || 0;
                
                // Calculate position change based on mouse movement and sensitivity
                const positionChange = (deltaX * this.sensitivity) / 5;
                
                // Update current position
                this.currentPosition += positionChange;
                
                // Ensure position stays within bounds
                this.currentPosition = Math.max(0, Math.min(this.totalChars, this.currentPosition));
                
                // Update display
                this.updateDisplay();
                
                // Update virtual cursor position (centered during pointer lock)
                this.updateVirtualCursor(window.innerWidth / 2, window.innerHeight / 2);
            }
            
            startSelection(e) {
                this.isSelecting = true;
                
                // Get click position in text
                const clickPos = this.getTextPositionFromEvent(e);
                this.selectionStart = clickPos;
                this.selectionEnd = clickPos;
                
                // Update display to show initial selection
                this.updateDisplay();
            }
            
            handleSelectionMouseMove(e) {
                if (!this.isSelecting) return;
                
                // Get current mouse position in text
                const currentPos = this.getTextPositionFromEvent(e);
                this.selectionEnd = currentPos;
                
                // Update display to show extended selection
                this.updateDisplay();
            }
            
            finishSelection() {
                if (!this.isSelecting) return;
                
                this.isSelecting = false;
                
                // Ensure start is before end
                const start = Math.min(this.selectionStart, this.selectionEnd);
                const end = Math.max(this.selectionStart, this.selectionEnd);
                
                // Add to manual highlights if selection has length
                if (end > start) {
                    this.manualHighlights.push({ start, end });
                    this.manualHighlightCount++;
                    document.getElementById('manual-highlights').textContent = this.manualHighlightCount;
                }
                
                // Reset selection
                this.selectionStart = 0;
                this.selectionEnd = 0;
                
                // Update display without active selection
                this.updateDisplay();
            }
            
            getTextPositionFromEvent(e) {
                // Simple approximation - in a real implementation you would use Range APIs
                // For this demo, we'll use a simplified approach
                const rect = this.container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Approximate character position based on mouse position
                const charsPerLine = 80; // Rough estimate
                const lineHeight = 28; // Rough estimate based on font size and line height
                
                const line = Math.floor(y / lineHeight);
                const charInLine = Math.floor(x / (rect.width / charsPerLine));
                
                return Math.min(this.totalChars, line * charsPerLine + charInLine);
            }
            
            clearManualHighlights() {
                this.manualHighlights = [];
                this.manualHighlightCount = 0;
                document.getElementById('manual-highlights').textContent = '0';
                this.updateDisplay();
            }
            
            updateVirtualCursor(x, y) {
                this.virtualCursor.style.left = x + 'px';
                this.virtualCursor.style.top = y + 'px';
            }
            
            updateDisplay() {
                let formattedText = this.originalText;
                
                // Apply manual highlights first (they should be underneath)
                this.manualHighlights.forEach(highlight => {
                    const before = formattedText.substring(0, highlight.start);
                    const highlighted = formattedText.substring(highlight.start, highlight.end);
                    const after = formattedText.substring(highlight.end);
                    
                    formattedText = before + 
                        `<span class="manual-highlight">${highlighted}</span>` + 
                        after;
                });
                
                // Apply current selection if in selection mode
                if (this.readingMode === 'select' && this.isSelecting && this.selectionEnd > this.selectionStart) {
                    const start = Math.min(this.selectionStart, this.selectionEnd);
                    const end = Math.max(this.selectionStart, this.selectionEnd);
                    
                    const before = formattedText.substring(0, start);
                    const highlighted = formattedText.substring(start, end);
                    const after = formattedText.substring(end);
                    
                    formattedText = before + 
                        `<span class="highlight">${highlighted}</span>` + 
                        after;
                }
                
                // Apply flow highlighting if in flow mode
                if (this.readingMode === 'flow') {
                    const highlightStart = Math.floor(this.currentPosition);
                    const highlightLength = 15 + this.highlightSpeed * 3;
                    const highlightEnd = Math.min(this.totalChars, highlightStart + highlightLength);
                    
                    // We need to be careful not to double-highlight text that's already manually highlighted
                    // For simplicity in this demo, we'll just overlay the flow highlight
                    const before = formattedText.substring(0, highlightStart);
                    const highlighted = formattedText.substring(highlightStart, highlightEnd);
                    const after = formattedText.substring(highlightEnd);
                    
                    formattedText = before + 
                        `<span class="highlight">${highlighted}</span>` + 
                        after;
                }
                
                // Apply focus mode styling
                if (this.focusMode === 'fade') {
                    // Simple implementation - in a real app you'd need more sophisticated text processing
                    formattedText = formattedText.replace(/<span class="highlight">|<\/span>/g, '|');
                    const readUntil = this.readingMode === 'flow' ? this.currentPosition : this.selectionEnd;
                    const beforeRead = formattedText.substring(0, readUntil);
                    const afterRead = formattedText.substring(readUntil);
                    
                    formattedText = `<span class="read-text">${beforeRead}</span>${afterRead}`;
                    formattedText = formattedText.replace(/\|/g, '</span><span class="highlight">');
                } else if (this.focusMode === 'hide') {
                    // Similar simplified implementation for hide mode
                    formattedText = formattedText.replace(/<span class="highlight">|<\/span>/g, '|');
                    const readUntil = this.readingMode === 'flow' ? this.currentPosition : this.selectionEnd;
                    const beforeRead = formattedText.substring(0, readUntil);
                    const afterRead = formattedText.substring(readUntil);
                    
                    formattedText = `<span class="focused-read-text">${beforeRead}</span>${afterRead}`;
                    formattedText = formattedText.replace(/\|/g, '</span><span class="highlight">');
                }
                
                // Update the container with the new HTML
                this.container.innerHTML = formattedText;
                
                // Update words read
                const readPosition = this.readingMode === 'flow' ? 
                    Math.min(this.totalChars, this.currentPosition + 15 + this.highlightSpeed * 3) :
                    this.selectionEnd;
                this.updateWordsRead(readPosition);
                
                // Auto-scroll to keep relevant text in view
                const scrollPosition = this.readingMode === 'flow' ? this.currentPosition : this.selectionEnd;
                this.autoScrollToHighlight(scrollPosition);
                
                // Update status and progress
                this.updateStatus();
            }
            
            updateWordsRead(position) {
                const textToPosition = this.originalText.substring(0, position);
                this.wordsRead = textToPosition.split(/\s+/).filter(word => word.length > 0).length;
                document.getElementById('words-read').textContent = this.wordsRead;
                
                // Calculate reading speed
                if (this.startTime) {
                    const minutes = (Date.now() - this.startTime) / 60000;
                    const wpm = Math.round(this.wordsRead / minutes);
                    document.getElementById('reading-speed').textContent = isFinite(wpm) ? wpm : 0;
                }
            }
            
            autoScrollToHighlight(charPosition) {
                // Calculate approximate pixel position
                const approxPixels = (charPosition / this.totalChars) * this.textContainer.scrollHeight;
                
                // Smoothly scroll to position
                this.textContainer.scrollTo({
                    top: approxPixels - 150,
                    behavior: 'smooth'
                });
            }
            
            startReadFlow() {
                this.isActive = true;
                this.currentPosition = 0;
                this.startTime = Date.now();
                document.getElementById('status').textContent = 'Active';
                this.showVirtualCursor();
                
                // Request pointer lock if in flow mode
                if (this.readingMode === 'flow') {
                    this.textContainer.requestPointerLock();
                }
                
                this.updateDisplay();
                this.startReadingTimer();
            }
            
            startReadingTimer() {
                clearInterval(this.readingTimer);
                this.readingTimer = setInterval(() => {
                    if (this.startTime) {
                        const seconds = Math.floor((Date.now() - this.startTime) / 1000);
                        const minutes = Math.floor(seconds / 60);
                        const remainingSeconds = seconds % 60;
                        document.getElementById('reading-time').textContent = 
                            `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
                    }
                }, 1000);
            }
            
            reset() {
                this.isActive = false;
                this.currentPosition = 0;
                this.wordsRead = 0;
                this.startTime = null;
                this.isSelecting = false;
                this.selectionStart = 0;
                this.selectionEnd = 0;
                clearInterval(this.readingTimer);
                
                // Exit pointer lock
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Reset to original text
                this.container.innerHTML = this.originalText;
                
                document.getElementById('status').textContent = 'Ready to Start';
                document.getElementById('words-read').textContent = '0';
                document.getElementById('reading-time').textContent = '0:00';
                document.getElementById('reading-speed').textContent = '0';
                this.hideVirtualCursor();
                this.updateStatus();
                
                // Reset scroll position
                this.textContainer.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }
            
            toggleCursor() {
                this.cursorVisible = !this.cursorVisible;
                
                if (this.cursorVisible) {
                    this.showSystemCursor();
                    this.hideVirtualCursor();
                    document.getElementById('toggle-cursor-btn').textContent = 'Hide System Cursor';
                } else {
                    this.hideSystemCursor();
                    if (this.isActive) {
                        this.showVirtualCursor();
                    }
                    document.getElementById('toggle-cursor-btn').textContent = 'Show System Cursor';
                }
            }
            
            updateModeStatus() {
                if (this.pointerLocked) {
                    this.modeIndicator.style.display = 'block';
                    this.scrollIndicator.style.display = 'block';
                } else {
                    this.modeIndicator.style.display = 'none';
                    this.scrollIndicator.style.display = 'none';
                }
            }
            
            hideSystemCursor() {
                document.body.classList.add('cursor-hidden');
            }
            
            showSystemCursor() {
                document.body.classList.remove('cursor-hidden');
            }
            
            showVirtualCursor() {
                this.virtualCursor.style.display = 'block';
            }
            
            hideVirtualCursor() {
                this.virtualCursor.style.display = 'none';
            }
            
            updateStatus() {
                const progress = this.readingMode === 'flow' ? 
                    Math.floor((this.currentPosition / this.totalChars) * 100) :
                    Math.floor((this.selectionEnd / this.totalChars) * 100);
                    
                document.getElementById('progress').textContent = progress + '%';
                document.getElementById('progress-bar').style.width = progress + '%';
                
                if (progress >= 95) {
                    document.getElementById('status').textContent = 'Reading Complete';
                }
            }
            
            updateControls() {
                document.getElementById('sensitivity-value').textContent = this.sensitivity;
                document.getElementById('speed-value').textContent = this.highlightSpeed;
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ReadFlowPro('text-content');
        });
    </script>
</body>
</html>